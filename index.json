[{"categories":["生活"],"content":"首先打开试题，阅读试题，发现NOIp竟然有字符串，还有Special Judge？我考前还认为NOIp从来没考过，这次也应该不会涉及到，所以我也没有怎么复习字符串。首先看T1，第一眼发现是网络瘤？然后在后面我发现就是一个水题–拓扑排序板子，但发现要输出分数，于是写了一个分数类，花了30min过了大样例。但是赛后听说要爆long long，所以希望CCF的数据水一点。然后是T2，我首先思考$O(n^2)$的算法，后来我发现可以枚举$|C|$，再利用KMP求出最小循环节$p$，枚举$p$的倍数$t=kp$，如果$(n-|c|)\\mod t=0 $，再枚举$|A|$，如果$F(A)\\le F(C)$则$ans\\leftarrow ans+1$，再用前缀和优化一下。然后我想了一会儿如何优化到$O(nlogn)$思考未果后，又想拿有且仅有一种字符的部分分，但发现可能要用到数论知识，就去看T3了。我最开始没有什么想法，后来想到了一个$O(n^2m)$的做法，我马上打完了代码，还研究了SPJ如何编译，最后使用checker时，发现我的做法是错误的，我再看了题面，发现我忽略了第二点限制，我想修补这个错误，可发现无法修复，于是我就放弃70，思考40分$O(nm^2)$的做法，想了一个做法，但很快发现是假的，最后我就直接去看T4了，最后本来想打一个迭代加深骗20分的，结果死活调不过样例，于是此题成功爆0。最后一题，首先想的是模拟，然后又想了一个方法，维护跳了$i$步的坐标最大/最小值，记录跳$i$步的方案数，通过递推求解步数，然而我打了后。样例却死活都过不去，就只好交了暴力模拟。 美好的OI生活终于画上了句号，还记得当初刚刚学习C++语法的时候的新鲜感，以及经过不断调试终于AC的快乐。为了OI的学习，我们牺牲了众多节假日，也进行了长达3个月的停课训练。希望在未来的时间里，回归文化课，在大学里于算法竞赛再次相聚。 -AFO 2020.12.5 ","date":"2020-12-05","objectID":"/noip--the-last-examination/:0:0","series":["游记"],"tags":null,"title":"NOIp退役记","uri":"/noip--the-last-examination/#"},{"categories":["技术"],"content":" 题意给定一个有向无环图，等概率的选一条路径，求路径长度的期望。 ","date":"2020-10-31","objectID":"/luogu-p6154/:1:0","series":["算法"],"tags":["DP","概率期望"],"title":"题解 P6154 【游走】","uri":"/luogu-p6154/#题意"},{"categories":["技术"],"content":" 题解由期望的公式$E(x)=\\sum_{i=1}^\\infty i \\times p(x=i)$，由于每一条路径出现的概率是相等的，设所有路径长度为$len$，路径条数为$cnt$，所以我们就可以得到路径长度的期望$E(x)=len/cnt$。那么，对于$len$和$cnt$的求法，我们可以使用拓扑排序。令$f_u$为到$u$的路径长度总和，$g_u$为到$u$的路径条数，对于任意一点$u$，考虑其入边，他能被入边上的另外一点$v$更新，到达$u$的路径条数为到达$v$的路径条数之和再加上1，到达$u$的路径的权值之和为到达$v$的路径权值之和+到达$v$的路径数量，具体地，$g_u=\\sum g_v+1$，$f_u=\\sum(f_v+g_v)$。这样，我们就可以求出答案了。对于取模运算，乘以其逆元即可。 ","date":"2020-10-31","objectID":"/luogu-p6154/:2:0","series":["算法"],"tags":["DP","概率期望"],"title":"题解 P6154 【游走】","uri":"/luogu-p6154/#题解"},{"categories":["技术"],"content":" 代码 #include\u003ccstdio\u003e #include\u003cqueue\u003e using namespace std; const int maxn=1e6+10,p=998244353; int n,m,k; long long len,sum; struct node{ int to,next; }edge[maxn]; int head[maxn],deg[maxn]; long long f[maxn],g[maxn]; void add(int u,int v) { edge[++k].to=v; edge[k].next=head[u]; head[u]=k; } queue\u003cint\u003eq; long long qpow(long long a,long long b) { if(b==0)return 1; long long c=qpow(a,b/2); c=c*c%p; if(b\u00261)c=c*a%p; return c; } int main(){ scanf(\"%d%d\",\u0026n,\u0026m); for(int i=1,u,v;i\u003c=m;i++){ scanf(\"%d%d\",\u0026u,\u0026v); add(u,v); deg[v]++; } for(int i=1;i\u003c=n;i++) if(!deg[i]) q.push(i); while(q.size()){ int u=q.front(); q.pop(); f[u]++; for(int i=head[u];i;i=edge[i].next){ int v=edge[i].to; f[v]=(f[u]+f[v])%p; g[v]=(g[v]+g[u]+f[u])%p; deg[v]--; if(!deg[v]) q.push(v); } } for(int i=1;i\u003c=n;i++) len=(len+g[i])%p,sum=(sum+f[i])%p; printf(\"%lld\",len*qpow(sum,p-2)%p); return 0; } ","date":"2020-10-31","objectID":"/luogu-p6154/:3:0","series":["算法"],"tags":["DP","概率期望"],"title":"题解 P6154 【游走】","uri":"/luogu-p6154/#代码"},{"categories":["技术"],"content":" 二分图最大独立集本题是给定$n$条垂直于坐标轴的线段，让我们选尽量多的线段，使得他们的交集为空。观察发现，设线段$l_1$和$l_2$交于点$p$，那么$p$只能与其中的一条线段匹配，于是我们可以建立如下的二分图模型：将横着的线段和竖着的线段分别看做两个点集，若两条线段有交点，则在其中连一条边，那么问题就被转化成了二分图的最大独立集问题。因为如果选取的点集中是不存在边连接其中两点的，那么任意两条线段之间就必然没有交点，而我们又求的是最大的独立集，那么满足线段的个数尽量多的要求，根据最大独立集=点数-最大匹配，那么我们只需求得二分图的最大匹配即可。 #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003calgorithm\u003e using namespace std; const int maxn=1e3+10; int n,cnt1,cnt2,ans; struct seg{ int c,l,r; }a[maxn],b[maxn]; int mapp[maxn][maxn],use[maxn],result[maxn]; bool dfs(int x) { for(int i=1;i\u003c=cnt2;i++){ if(mapp[x][i]\u0026\u0026!use[i]){ use[i]=1; if(!result[i]||dfs(result[i])){ result[i]=x; return true; } } } return false; } int main(){ scanf(\"%d\",\u0026n); for(int i=1,_a,_b,_c,_d;i\u003c=n;i++){ scanf(\"%d%d%d%d\",\u0026_a,\u0026_b,\u0026_c,\u0026_d); if(_a==_c)a[++cnt1]={_a,_b,_d}; if(_b==_d)b[++cnt2]={_b,_a,_c}; } for(int i=1;i\u003c=cnt1;i++) if(a[i].l\u003ea[i].r) swap(a[i].l,a[i].r); for(int i=1;i\u003c=cnt2;i++) if(b[i].l\u003eb[i].r) swap(b[i].l,b[i].r); for(int i=1;i\u003c=cnt1;i++){ for(int j=1;j\u003c=cnt2;j++){ if(a[i].l\u003c=b[j].c\u0026\u0026a[i].r\u003e=b[j].c\u0026\u0026b[j].l\u003c=a[i].c\u0026\u0026b[j].r\u003e=a[i].c){ mapp[i][j]=1; } } } for(int i=1;i\u003c=cnt1;i++){ memset(use,0,sizeof use); if(dfs(i))ans++; } printf(\"%d\",n-ans); return 0; } ","date":"2020-10-12","objectID":"/luogu-p3033/:1:0","series":["算法"],"tags":["二分图"],"title":"题解 P3033 【[USACO11NOV]Cow Steeplechase G】","uri":"/luogu-p3033/#二分图最大独立集"},{"categories":["生活"],"content":"这篇游记本来打算写的，但忘掉了，便一直到了现在。回忆有些不准确了。 经过之前的一些学习，我对CSP-S有了更为清晰的认识。CSP-S是我在NOIP之前训练的绝佳机会。怀着这样的心情，我便坐着hfl教练的车前往了电子科技大学。由于CSP初赛的要求较高，我们学校OI队仅剩下了5个人，感觉有些冷清。进入考场后，等待了一些时间，拿到题目。我首先看T1，好像是一个模拟，我便更加细致的浏览了题目，并进行了一些思考，尝试进行了一些模拟。写着写着，越发觉得题目的不对劲，感觉细节很多，又花费了许多时间，一个多小时，也未能完成。于是我看了T2，稍微思考后，发现T2题目较水，便快速完成了T2，没再管。然后是T3，我首先花了几分钟想出了暴力解法，然后我想用数据结构优化一下，但我看了数据，觉得使用线段树也无法得到更高的分数，我又想了其他的高级数据结构或许可以得到更高分数，但我也无法实现，就交了朴素暴力。然后我在赛后听说如果写了线段树，我可以得到70分，真是遗憾。最后是T4，我想了n=3的做法，想拓展，但毫无头绪。期间我也间断性的写T1，但也没写出来。 赛后看到成绩为125分，不理想，未能拿到一等奖，反映出我的实力问题。总之，还是要继续加油。 ","date":"2020-10-10","objectID":"/travel-recording-of-csp2020/:0:0","series":["游记"],"tags":null,"title":"CSP-S 2020 游记","uri":"/travel-recording-of-csp2020/#"},{"categories":["技术"],"content":" 题解：这道题是要求以下两个操作：删除序列上的一个数或查询一段区间的最值。对于这道题，我们可以用线段树求解。对于每一个节点，我们只需要记录当前节点的真实节点数量以及最值。当删除节点时，如果待删除的节点小于该节点左儿子的大小，在左子树递归求解，反之在右子树求解。当遍历到叶子节点时，将当前节点的大小修改为0，分别把极大值和极小值赋为-inf和inf，这样就可以避免答案错误。查询操作也是同理，根据子树的大小判断应该往那颗子树遍历。 ","date":"2020-10-08","objectID":"/luogu-p6011/:1:0","series":["算法"],"tags":["线段树"],"title":"题解 P6011 【[SCOI2006]动态最值】","uri":"/luogu-p6011/#题解"},{"categories":["技术"],"content":" 代码： #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003calgorithm\u003e using namespace std; const int maxn=1e6+10,inf=0x7f7f7f7f; int n,m; int a[maxn]; struct node{ int _max,_min,size,l,r; }tree[maxn*4]; void build(int id,int l,int r) { tree[id].l=l,tree[id].r=r; if(l==r){ tree[id]._min=tree[id]._max=a[l]; tree[id].size=1; return ; } int mid=(l+r)/2; build(id*2,l,mid),build(id*2+1,mid+1,r); tree[id]._max=max(tree[id*2]._max,tree[id*2+1]._max); tree[id]._min=min(tree[id*2]._min,tree[id*2+1]._min); tree[id].size=tree[id*2].size+tree[id*2+1].size; } void update(int id,int x) { if(tree[id].size==1){ tree[id].size=0; tree[id]._min=inf; tree[id]._max=-inf; return ; } if(x\u003c=tree[id*2].size)update(id*2,x); else update(id*2+1,x-tree[id*2].size); tree[id].size=tree[id*2].size+tree[id*2+1].size; tree[id]._max=max(tree[id*2]._max,tree[id*2+1]._max); tree[id]._min=min(tree[id*2]._min,tree[id*2+1]._min); } node query(int id,int l,int r) { if(tree[id].size==r-l+1)return tree[id]; if(r\u003c=tree[id*2].size)return query(id*2,l,r); else if(l\u003etree[id*2].size)return query(id*2+1,l-tree[id*2].size,r-tree[id*2].size); else { node t1=query(id*2,l,tree[id*2].size),t2=query(id*2+1,1,r-tree[id*2].size),t3; t3._max=max(t1._max,t2._max),t3._min=min(t1._min,t2._min); return t3; } } int main(){ scanf(\"%d%d\",\u0026n,\u0026m); for(int i=1;i\u003c=n;i++) scanf(\"%d\",\u0026a[i]); build(1,1,n); for(int i=1,opt,x,y;i\u003c=m;i++) { scanf(\"%d\",\u0026opt); if(opt==1){ scanf(\"%d\",\u0026x); update(1,x); }else{ scanf(\"%d%d\",\u0026x,\u0026y); node t=query(1,x,y); printf(\"%d %d\\n\",t._min,t._max); } } return 0; } ","date":"2020-10-08","objectID":"/luogu-p6011/:2:0","series":["算法"],"tags":["线段树"],"title":"题解 P6011 【[SCOI2006]动态最值】","uri":"/luogu-p6011/#代码"},{"categories":["技术"],"content":" 题解：观察表达式，发现要求的是两个点，满足每个点的权值之和乘以该点到这两点的距离的较小值之和最小。我们可以发现，对于树上的两个点，到一个点为最小距离的集合和到另外一个点为最小距离的点的集合之间是没有交集的。故我们可以枚举边，对两颗子树分别求带权值的树的重心，则求得的正好是表达式的值。但是这任然是$O(n^2)$的，观察方程:$f_v=f_u+size_u-size_v$，若$v$比$u$更优，当且仅当$2size_v\u003esize_1$，且满足$2size_v\u003esize_1$的$v$有且仅有一个，故可以处理出最大儿子和次大儿子，当连接最大儿子的边断裂时，使用次大儿子计算，此时时间复杂度即为$O(nh)$的。 ","date":"2020-09-26","objectID":"/luogu-p2726/:1:0","series":["算法"],"tags":["树的重心"],"title":"题解 P2726 【[SHOI2005]树的双中心】","uri":"/luogu-p2726/#题解"},{"categories":["技术"],"content":" 代码： #include\u003ccstdio\u003e #include\u003calgorithm\u003e #define int long long using namespace std; const int maxn=1e6+10; int n,k,cut,ans=0x7f7f7f7f7f7f7f7fll; struct node{ int to,next; }edge[maxn]; int head[maxn],fa[maxn]; int w[maxn],son1[maxn],son2[maxn],size[maxn],a[maxn],deep[maxn]; void add(int u,int v) { edge[++k].to=v; edge[k].next=head[u]; head[u]=k; } void dfs(int u,int f) { fa[u]=f; size[u]=w[u]; a[u]=w[u]*deep[u]; for(int i=head[u];i;i=edge[i].next) { int v=edge[i].to; if(v!=f) { deep[v]=deep[u]+1; dfs(v,u); size[u]+=size[v]; a[u]+=a[v]; if(size[son1[u]]\u003c=size[v]){ son2[u]=son1[u]; son1[u]=v; }else if(size[son2[u]]\u003c=size[v]){ son2[u]=v; } } } } void get_ans(int u,int sz,int num,int \u0026cnt) { cnt=min(cnt,num); int v=son1[u]; if(size[son1[u]]\u003csize[son2[u]]||v==cut)v=son2[u]; if(v\u0026\u0026size[v]*2\u003esize[u])get_ans(v,sz,num+sz-2*size[v],cnt); } void solve(int u) { for(int j=head[u];j;j=edge[j].next) { int v=edge[j].to; if(v!=fa[u]) { int _a=0x7f7f7f7f7f7f7f7fll,b=0x7f7f7f7f7f7f7f7fll; cut=v; for(int i=u;i;i=fa[i]) size[i]-=size[v]; get_ans(1,size[1],a[1]-a[v],_a); get_ans(v,size[v],a[v]-size[v]*deep[v],b); ans=min(ans,_a+b); for(int i=u;i;i=fa[i]) size[i]+=size[v]; solve(v); } } } main(){ //freopen(\"center.in\",\"r\",stdin); //freopen(\"center.out\",\"w\",stdout); scanf(\"%lld\",\u0026n); for(int i=1;i\u003cn;i++) { int u,v; scanf(\"%lld%lld\",\u0026u,\u0026v); add(u,v); add(v,u); } for(int i=1;i\u003c=n;i++) scanf(\"%lld\",\u0026w[i]); dfs(1,0); solve(1); printf(\"%lld\",ans); return 0; } ","date":"2020-09-26","objectID":"/luogu-p2726/:2:0","series":["算法"],"tags":["树的重心"],"title":"题解 P2726 【[SHOI2005]树的双中心】","uri":"/luogu-p2726/#代码"},{"categories":["技术"],"content":" 题解：本题是给定一个序列$a$，多次询问某数列是否是该序列的子序列。对于每一个询问的序列$b$，对于$b_1$，我们可以在原序列在$[1,n]$中寻找第一个$b_i$出现的位置$p_1$,再在$[p_1+1,n]$中寻找$b_2$出现的位置$p_2$，以此类推，如果对于存在一个位置不能找到则无解，反之有解。那么如何快速求解在原序列中第一次出现的位置呢？我们可以用二分查找，对于每一个数建立一个vector，在其中二分查找出第一个大于$p$的位置。 ","date":"2020-09-26","objectID":"/luogu-p3500/:1:0","series":["算法"],"tags":["二分查找"],"title":"题解 P3500 【[POI2010]TES-Intelligence Test】","uri":"/luogu-p3500/#题解"},{"categories":["技术"],"content":" 代码： #include\u003ccstdio\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; const int maxn=1e6+10; int n,m; int a[maxn],c[maxn]; vector\u003cint\u003epos[maxn]; int read(){ int x=0,sign=1; char ch=getchar(); while(ch\u003e'9'||ch\u003c'0') { if(ch=='-')sign=-sign; ch=getchar(); } while(ch\u003e='0'\u0026\u0026ch\u003c='9') x=x*10+ch-48, ch=getchar(); return x*sign; } int main(){ n=read(); for(int i=1;i\u003c=n;i++) a[i]=read(); for(int i=1;i\u003c=n;i++) pos[a[i]].push_back(i); m=read(); for(int i=1;i\u003c=m;i++) { int l=read(),p=0,book=0; for(int j=1;j\u003c=l;j++) c[j]=read(); for(int j=1;j\u003c=l;j++) { auto t=upper_bound(pos[c[j]].begin(),pos[c[j]].end(),p); if(t==pos[c[j]].end()){ book=1; puts(\"NIE\"); break; } else p=*t; } if(!book) puts(\"TAK\"); } return 0; } ","date":"2020-09-26","objectID":"/luogu-p3500/:2:0","series":["算法"],"tags":["二分查找"],"title":"题解 P3500 【[POI2010]TES-Intelligence Test】","uri":"/luogu-p3500/#代码"},{"categories":["技术"],"content":" 题解：本题是在数列$a_i$中，求满足$i\u003cj\u003ck$且$a_i\u003ea_j\u003ea_k$的三元组的个数。对于本题，我们可以枚举三元组的中间位置$i$，在其左边求得比他小的数的数的数量$a_i$，在其右边求得比他大的数的数量$b_i$，则最终答案为 $\\sum_{i=1}^na_ib_i$。具体地，我们可以用权值树状数组维护出$1-i$的数字出现的数量，我们从左往右遍历，对于数$a_i$，我们首先查询小于$a_i$的数的数量，并在树状数组中更新该数字。按照同样的方法可以求出$c_i$。本题数据较大，需注意离散化。 ","date":"2020-09-26","objectID":"/luogu-cf61e/:1:0","series":["算法"],"tags":["树状数组"],"title":"题解 CF61E 【Enemy is weak】","uri":"/luogu-cf61e/#题解"},{"categories":["技术"],"content":" 代码： #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003calgorithm\u003e using namespace std; const int maxn=1e6+10; int n; long long ans; int a[maxn],l[maxn],r[maxn],tree[maxn],b[maxn]; void lsh() { for(int i=1;i\u003c=n;i++) b[i]=a[i]; sort(b+1,b+n+1); int m=unique(b+1,b+n+1)-b-1; for(int i=1;i\u003c=n;i++) a[i]=lower_bound(b+1,b+m+1,a[i])-b; } inline int lowbit(int x) { return x\u0026-x; } void update(int x,int val) { for(int i=x;i\u003c=n;i+=lowbit(i))tree[i]+=val; } int query(int x) { int ans=0; for(int i=x;i;i-=lowbit(i))ans+=tree[i]; return ans; } int main(){ scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;i++) scanf(\"%d\",\u0026a[i]); lsh(); for(int i=1;i\u003c=n;i++) l[i]=(query(n)-query(a[i])),update(a[i],1); memset(tree,0,sizeof tree); for(int i=n;i\u003e=1;i--) r[i]=query(a[i]-1),update(a[i],1); for(int i=1;i\u003c=n;i++) ans+=1ll*l[i]*r[i]; printf(\"%lld\",ans); return 0; } ","date":"2020-09-26","objectID":"/luogu-cf61e/:2:0","series":["算法"],"tags":["树状数组"],"title":"题解 CF61E 【Enemy is weak】","uri":"/luogu-cf61e/#代码"},{"categories":["技术"],"content":" 可持久化01trie设$s_n=a_1\\oplus a_2\\oplus a_3\\oplus …\\oplus a_n$,对于题中所给的对一段区间的询问，我们就可以转化为前缀异或，即$a_p\\oplus a_{p+1}\\oplus a_{p+2}\\oplus …\\oplus a_n\\oplus x=s_{p-1}\\oplus s_n\\oplus x$。这样，问题就转化为了在给定的区间$[L,R]$中，求出与$s_n\\oplus x$异或的答案最大的数。于是我们可以建$n$棵01trie,第$i$棵代表区间$[1,i]$的值,并在每个节点存储数字个数,对于每个询问，我们只需将两颗树相减就得到了当前区间的信息。在01trie上，我们从高位到低位贪心，假设$x$最高位为1，如果当前区间由最高为0的数，则一定要选，否则无论如何都不可能比他更优，以此类推，由高到低依次确定每一位的值。 #include\u003ccstdio\u003e #include\u003ciostream\u003e using namespace std; const int maxn=3e7+10; int n,m,k; int a[maxn],sum[maxn]; struct tire{ int size,son[2]; }tree[maxn]; int root[maxn]; int build(int x) { int now=++k; tree[now].size=1; if(x==0)return now; tree[now].son[0]=build(x-1); return now; } int update(int pre,int x,int pos) { int now=++k; if(pos==0){ tree[now].size=tree[pre].size+1; return now; } tree[now]=tree[pre]; tree[now].son[1\u0026(x\u003e\u003e(pos-1))]=update(tree[pre].son[1\u0026(x\u003e\u003e(pos-1))],x,pos-1); tree[now].size=tree[tree[now].son[0]].size+tree[tree[now].son[1]].size; return now; } int query(int pre,int now,int x,int pos) { if(!pos)return 0; return (tree[tree[now].son[1^(1\u0026(x\u003e\u003e(pos-1)))]].size-tree[tree[pre].son[1^(1\u0026(x\u003e\u003e(pos-1)))]].size)? query(tree[pre].son[1^(1\u0026(x\u003e\u003e(pos-1)))],tree[now].son[1^(1\u0026(x\u003e\u003e(pos-1)))],x,pos-1)+(1\u003c\u003c(pos-1)): query(tree[pre].son[1\u0026(x\u003e\u003e(pos-1))],tree[now].son[1\u0026(x\u003e\u003e(pos-1))],x,pos-1); } int main(){ scanf(\"%d%d\",\u0026n,\u0026m); for(int i=1;i\u003c=n;i++) scanf(\"%d\",\u0026a[i]), sum[i]=sum[i-1]^a[i]; root[0]=++k; for(int i=0;i\u003c=n;i++) root[i+1]=update(root[i],sum[i],25); for(int i=1,l,r,x;i\u003c=m;i++){ char opt; scanf(\"\\n%c\",\u0026opt); if(opt=='A')scanf(\"%d\",\u0026x),sum[n+1]=sum[n]^x,root[n+2]=update(root[n+1],sum[n+1],25),n++; else{ scanf(\"%d%d%d\",\u0026l,\u0026r,\u0026x); printf(\"%d\\n\",query(root[l-1],root[r],x^sum[n],25)); } } return 0; } ","date":"2020-09-26","objectID":"/luogu-p4735/:1:0","series":["算法"],"tags":["可持久化","字典树"],"title":"题解 P4735 【最大异或和】","uri":"/luogu-p4735/#可持久化01trie"},{"categories":["技术"],"content":" 题解：本道题可以先按照成绩排序，再枚举成绩的中位数求解。对于每一个成绩作为中位数的学生，可以求出成绩小于中位数的学生的最小的$n/2$的奖学金之和$a$以及成绩大于中位数的学生的最小的$n/2$的奖学金之和$b$，设作为中位数的学生的奖学金为$c$，若$a+b+c\u003c=f$则该成绩作为中位数是合法的。这样，我们就可以求得答案了。对于$a$和$b$的求解，我们可以使用堆。我们从左往右遍历，若当前位置$i$的值$t_i$大于堆顶元素$m$，则选择当前元素，将堆顶元素出堆，将该元素入堆，$a_i=a_{i-1}-m+t_i$，否则，$a_i=a_{i-1}$。 ","date":"2020-09-26","objectID":"/luogu-p3963/:1:0","series":["算法"],"tags":["排序","堆"],"title":"题解 P3963 【[TJOI2013] 奖学金】","uri":"/luogu-p3963/#题解"},{"categories":["技术"],"content":" 代码： #include\u003ccstdio\u003e #include\u003cqueue\u003e #include\u003calgorithm\u003e using namespace std; const int maxn=1e6+10; int n,c,f,ans; int suma[maxn],sumb[maxn]; struct node{ int a,b; }z[maxn]; bool cmp(node a,node b) { return a.a\u003cb.a; } priority_queue\u003cint\u003eq; int main(){ scanf(\"%d%d%d\",\u0026n,\u0026c,\u0026f); for(int i=1;i\u003c=c;i++) scanf(\"%d%d\",\u0026z[i].a,\u0026z[i].b); sort(z+1,z+c+1,cmp); for(int i=1;i\u003c=n/2;i++) q.push(z[i].b),suma[i]=suma[i-1]+z[i].b; for(int i=n/2+1;i\u003c=c;i++) { if(z[i].b\u003cq.top())suma[i]=suma[i-1]-q.top()+z[i].b,q.pop(),q.push(z[i].b); else suma[i]=suma[i-1]; } while(q.size())q.pop(); for(int i=c;i\u003e=c-n/2+1;i--) q.push(z[i].b),sumb[i]=sumb[i+1]+z[i].b; for(int i=c-n/2;i\u003e=1;i--) { if(z[i].b\u003cq.top())sumb[i]=sumb[i+1]-q.top()+z[i].b,q.pop(),q.push(z[i].b); else sumb[i]=sumb[i+1]; } for(int i=n/2+1;i\u003c=c-n/2;i++) { if(suma[i-1]+sumb[i+1]+z[i].b\u003c=f) ans=z[i].a; } printf(\"%d\",ans!=0?ans:-1); return 0; } ","date":"2020-09-26","objectID":"/luogu-p3963/:2:0","series":["算法"],"tags":["排序","堆"],"title":"题解 P3963 【[TJOI2013] 奖学金】","uri":"/luogu-p3963/#代码"},{"categories":["技术"],"content":" 题解：本题是有n个城市，用k个电缆使得城市两两配对，且任意一个城市只能链接一个电缆，求最小的距离和。观察发现，我们一定是配对两两相邻的城市，这样才能使得距离最小。所以就可以转化为P1792的模型，把相邻的城市看做一个点，选点不能相邻，使得和最小。这是反悔贪心的一道题，首先考虑一种错误的贪心：选最大的，然后在其他合法的位置选最大的，但是这样贪心很容易找出反例。但我们发现，如果不选最大的，那么一定会选最大值左右两个位置。所以，我们可以想到如下算法：首先将所有元素入小根堆，每次出堆时，将左右两边的元素标记，并将左边的元素加右边元素减去该元素的新点放入堆，并在链表上更新该点的左右值，重复该过程，直至循环次数达到k。 ","date":"2020-09-26","objectID":"/luogu-sp1553/:1:0","series":["算法"],"tags":["贪心"],"title":"题解 SP1553 【BACKUP - Backup Files】","uri":"/luogu-sp1553/#题解"},{"categories":["技术"],"content":" 代码： #include\u003ccstdio\u003e #include\u003cqueue\u003e #include\u003ccstring\u003e using namespace std; const int maxn=1e6+10; int n,k,T; int num[maxn],net[maxn],pre[maxn],book[maxn]; long long a[maxn],ans; struct node{ int id; long long w; node(int _id,long long _w){ id=_id,w=_w; } friend bool operator\u003c(node a,node b){ return a.w\u003eb.w; } }; priority_queue\u003cnode\u003eq; int main(){ scanf(\"%d\",\u0026T); while(T--) { ans=0; memset(book,0,sizeof book); while(q.size())q.pop(); scanf(\"%d%d\",\u0026n,\u0026k); for(int i=1;i\u003c=n;i++) scanf(\"%d\",\u0026num[i]); for(int i=1;i\u003cn;i++) a[i]=num[i+1]-num[i]; for(int i=1;i\u003c=n-1;i++) net[i]=i+1; for(int i=1;i\u003c=n-1;i++) pre[i]=i-1; a[0]=a[n]=0x7f7f7f7f7fll; for(int i=1;i\u003cn;i++) q.push(node(i,a[i])); for(int i=1;i\u003c=k;i++) { while(book[q.top().id])q.pop(); node t=q.top(); q.pop(); ans+=t.w; book[pre[t.id]]=book[net[t.id]]=1; a[t.id]=a[pre[t.id]]+a[net[t.id]]-a[t.id]; q.push(node(t.id,a[t.id])); net[t.id]=net[net[t.id]]; pre[t.id]=pre[pre[t.id]]; pre[net[t.id]]=t.id; net[pre[t.id]]=t.id; } printf(\"%lld\\n\",ans); } return 0; } ","date":"2020-09-26","objectID":"/luogu-sp1553/:2:0","series":["算法"],"tags":["贪心"],"title":"题解 SP1553 【BACKUP - Backup Files】","uri":"/luogu-sp1553/#代码"},{"categories":["技术"],"content":" 题意给定一棵树，树上有$m$种糖果,美味指数为$V_i$，共有$q$次操作，每次询问树上的一条路径$u-\u003ev$，第$i$次品尝$j$种糖果的新奇指数为$W_i$，并且愉悦指数$H$增加$V_j \\times W_i$，求最终的愉悦指数或把点$x$的糖果类型改为$y$。 ","date":"2020-08-25","objectID":"/luogu-p4074/:1:0","series":["算法"],"tags":["莫队"],"title":"题解 P4074 【[WC2013]糖果公园】","uri":"/luogu-p4074/#题意"},{"categories":["技术"],"content":" 题解树上带修改莫队。 考虑把树用欧拉序变成序列,对于每一条询问的路径，可以转化为在序列上的询问。如果两个点的LCA不等于其中之一，序列上的区间应该为两个点在欧拉序上第一次的位置之间的区间∪LCA，否则，序列上的区间应为第一个点后出现的位置到第二个点第一次出现的位置。在区间内，只有出现一次的点才会被记入答案。 维护当前区间内各种颜色出现的次数。当区间内的某个点的个数变为1时，愉悦指数增加(该点的颜色出现次数+1)$\\times$该点颜色的美味指数，同时，该颜色出现次数+1. 对于修改操作，可以仿照普通带修改莫队，增加一维时间戳，记录每次查询操作在第几次修改操作之后以及当前序列是第几次修改操作之后的。当序列的时间戳i小于询问的时间戳j时，执行j到i的修改操作，反之，还原i到j的修改操作。如果修改的节点在询问的节点之中，维护相应的信息。 ","date":"2020-08-25","objectID":"/luogu-p4074/:2:0","series":["算法"],"tags":["莫队"],"title":"题解 P4074 【[WC2013]糖果公园】","uri":"/luogu-p4074/#题解"},{"categories":["技术"],"content":" 代码 #include\u003ccmath\u003e #include\u003ccstdio\u003e #include\u003calgorithm\u003e using namespace std; const int maxn=1e6+10; int n,m,q,k,cnt,t1,t2,l=1,r,now,block; int v[maxn],w[maxn],a[maxn]; long long num,ans[maxn]; struct node{ int to,next; }edge[maxn]; struct query{ int l,r,lca,id,t; }que[maxn]; struct Change{ int pos,color; }c[maxn]; int head[maxn]; int first[maxn],last[maxn],euler[maxn]; int fa[maxn],son[maxn],top[maxn],size[maxn],deep[maxn]; int book[maxn],flag[maxn]; int read() { int x=0; char ch=getchar(); while(ch\u003c'0'||ch\u003e'9') ch=getchar(); while(ch\u003c='9'\u0026\u0026ch\u003e='0') x=x*10+ch-48, ch=getchar(); return x; } bool cmp(query a,query b) { if(a.l/block==b.l/block) return a.r\u003cb.r; else return a.l/block\u003cb.l/block; } void add(int u,int v) { edge[++k].to=v; edge[k].next=head[u]; head[u]=k; } void dfs1(int u,int f) { first[u]=++cnt; euler[cnt]=u; size[u]=1; for(int i=head[u];i;i=edge[i].next) { int v=edge[i].to; if(v!=f) { deep[v]=deep[u]+1; dfs1(v,u); fa[v]=u; size[u]+=size[v]; if(size[son[u]]\u003csize[v]) son[u]=v; } } last[u]=++cnt; euler[cnt]=u; } void dfs2(int u,int tp) { top[u]=tp; if(son[u]) dfs2(son[u],tp); for(int i=head[u];i;i=edge[i].next) { int v=edge[i].to; if(v!=fa[u]\u0026\u0026v!=son[u]) dfs2(v,v); } } int lca(int u,int v) { while(top[u]!=top[v]) { if(deep[top[u]]\u003cdeep[top[v]]) swap(u,v); u=fa[top[u]]; } return deep[u]\u003cdeep[v]?u:v; } void update(int pos) { if(flag[pos]==0){ book[a[pos]]++; num+=(long long)v[a[pos]]*w[book[a[pos]]]; }else{ book[a[pos]]--; num-=(long long)v[a[pos]]*w[book[a[pos]]+1]; } flag[pos]^=1; } void change(int tme) { if(flag[c[tme].pos]==1) { book[c[tme].color]++; num+=(long long)v[c[tme].color]*w[book[c[tme].color]]; book[a[c[tme].pos]]--; num-=(long long)v[a[c[tme].pos]]*w[book[a[c[tme].pos]]+1]; } swap(c[tme].color,a[c[tme].pos]); } int main(){ n=read();m=read();q=read(); for(int i=1;i\u003c=m;i++) v[i]=read(); for(int i=1;i\u003c=n;i++) w[i]=read(); for(int i=1;i\u003cn;i++) { int u=read(),v=read(); add(u,v); add(v,u); } for(int i=1;i\u003c=n;i++) a[i]=read(); dfs1(1,1); dfs2(1,1); for(int i=1;i\u003c=q;i++) { int opt=read(),x=read(),y=read(); if(opt==0){ t1++; c[t1].pos=x; c[t1].color=y; }else{ t2++; que[t2].t=t1; que[t2].id=t2; que[t2].lca=lca(x,y); if(first[x]\u003efirst[y]) swap(x,y); if(que[t2].lca==x){ que[t2].l=first[x]; que[t2].r=first[y]; que[t2].lca=0; }else{ que[t2].l=last[x]; que[t2].r=first[y]; } } } block=pow(n,2.0/3); sort(que+1,que+t2+1,cmp); for(int i=1;i\u003c=t2;i++) { while(l\u003cque[i].l)update(euler[l++]); while(l\u003eque[i].l)update(euler[--l]); while(r\u003cque[i].r)update(euler[++r]); while(r\u003eque[i].r)update(euler[r--]); while(now\u003cque[i].t)change(++now); while(now\u003eque[i].t)change(now--); if(que[i].lca)update(que[i].lca); ans[que[i].id]=num; if(que[i].lca)update(que[i].lca); } for(int i=1;i\u003c=t2;i++) printf(\"%lld\\n\",ans[i]); return 0; } ","date":"2020-08-25","objectID":"/luogu-p4074/:3:0","series":["算法"],"tags":["莫队"],"title":"题解 P4074 【[WC2013]糖果公园】","uri":"/luogu-p4074/#代码"}]